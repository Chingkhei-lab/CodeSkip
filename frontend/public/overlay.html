<!DOCTYPE html>
<html>
<head>
  <title>Stealth Overlay</title>
  <style>
    :root {
      --overlay-alpha: 0.6;
    }
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: transparent;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      pointer-events: none;
    }
    #pill {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: rgba(0,0,0,var(--overlay-alpha));
      border-radius: 16px;
      padding: 6px 12px;
      color: #fff;
      font-size: 12px;
      white-space: nowrap;
      cursor: pointer;
      pointer-events: auto;
      z-index: 10001;
    }
    #pill.pill-thinking {
      display: block !important;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      max-width: 900px;
      text-align: center;
      font-size: 13px;
      cursor: default;
      pointer-events: none;
      transition: width 150ms ease-in-out, opacity 150ms ease-in-out;
    }
    #pill.pill-thinking .dots::after {
      content: '…';
      animation: blink 1.2s infinite;
    }
    @keyframes blink { 0%, 100% { opacity: 0.2; } 50% { opacity: 1; } }
    
    #navbar {
      position: fixed;
      top: 20px;
      left: 50%;
      transform: translateX(-50%);
      background-color: rgba(0, 0, 0, var(--overlay-alpha));
      border-radius: 20px;
      padding: 8px 16px;
      display: flex;
      gap: 15px;
      align-items: center;
      pointer-events: auto;
      z-index: 10000;
    }
    
    .shortcut {
      color: #fff;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid rgba(255, 255, 255, 0.2);
      border-radius: 12px;
      padding: 6px 12px;
      font-size: 13px;
      cursor: pointer;
    }
    
    .shortcut.disabled {
      opacity: 0.5;
      cursor: not-allowed;
      background: rgba(128, 128, 128, 0.1);
    }
    
    #shot-count {
      color: #aaa;
      font-size: 12px;
      margin-left: 5px;
    }
    
    #ai-result {
      position: fixed;
      top: 70px;
      left: 50%;
      transform: translateX(-50%);
      width: 80%;
      max-width: 900px;
      background-color: rgba(0, 0, 0, var(--overlay-alpha));
      border-radius: 15px;
      padding: 20px;
      z-index: 9999;
      display: none;
      max-height: 70vh;
      overflow-y: auto;
      pointer-events: auto;
      color: #fff;
      font-size: 14px;
      line-height: 1.5;
      scrollbar-width: none;
    }

    #ai-result::-webkit-scrollbar {
      width: 8px;
      height: 8px;
    }
    #ai-result::-webkit-scrollbar-track {
      background: rgba(255,255,255,0.08);
      border-radius: 8px;
    }
    #ai-result::-webkit-scrollbar-thumb {
      background: rgba(255,255,255,0.35);
      border-radius: 8px;
    }
    
    .result-header {
      display: flex;
      justify-content: space-between;
      margin-bottom: 15px;
      padding-bottom: 10px;
      border-bottom: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    .result-actions button {
      background: rgba(255, 255, 255, 0.1);
      color: white;
      border: none;
      border-radius: 8px;
      padding: 6px 12px;
      margin-left: 10px;
      cursor: pointer;
    }
    
    .result-actions button:hover {
      background: rgba(255, 255, 255, 0.2);
    }
    
    .thinking {
      color: #eee;
      margin-bottom: 10px;
    }
    
    pre {
      background: rgba(0, 0, 0, var(--overlay-alpha));
      border-radius: 8px;
      padding: 15px;
      overflow-x: auto;
      margin: 15px 0;
      font-family: 'Monaco', 'Menlo', 'Ubuntu Mono', monospace;
      font-size: 13px;
    }
    
    .error-message {
      color: #ff6b6b;
      background: rgba(255, 107, 107, 0.1);
      border: 1px solid rgba(255, 107, 107, 0.3);
      border-radius: 8px;
      padding: 12px;
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <div id="pill" style="display:none;">Ultracode</div>
  <div id="navbar" style="display:flex;">
    <div class="shortcut" id="screenshot">Screenshot (Ctrl+Shift+C)</div>
    <div class="shortcut disabled" id="solve" title="Take a screenshot first">Solve (Ctrl+Shift+E)</div>
    <div class="shortcut" id="start-over">Clear</div>
    <div id="shot-count">Shots: 0</div>
  </div>
  
  <div id="ai-result">
    <div class="result-header">
      <div>AI Response</div>
      <div class="result-actions">
        <button id="copy-result">Copy</button>
        <button id="close-result">Close</button>
      </div>
    </div>
    <div id="result-content"></div>
  </div>

  <script>
    const { ipcRenderer } = require('electron');
    const log = (m) => { try { ipcRenderer.send('log', String(m)); } catch {} };

    let shots = 0, isResultVisible = false, hasScreenshot = false;
    const pill = document.getElementById('pill');
    const navbar = document.getElementById('navbar');
    const panel = document.getElementById('ai-result');
    const cnt = document.getElementById('shot-count');
    const solveBtn = document.getElementById('solve');
    let ws, thinking = false, tSlow, tLong;

    // Response locking mechanism
    let responseLocked = false;
    let lockTimeout = null;
    let currentResponseContent = null;

    function handleWebSocketMessage(msg) {
      try {
        const d = JSON.parse(msg.data);
        
        if (d.type === 'response' && d.data?.ai_response) {
          stopThink();
          
          // Check if response is locked
          if (responseLocked) {
            log('[WS] Response locked - ignoring duplicate');
            console.log('[WS] Ignoring duplicate response (locked)');
            return;
          }
          
          const raw = d.data.ai_response;
          let explanation = '', code = '';
          
          if (typeof raw === 'string') {
            if (raw.trim().startsWith('{')) {
              try {
                const obj = JSON.parse(raw);
                explanation = obj.explanation || '';
                code = (obj.python_code || '').replace(/^```python?/,'').replace(/```$/,'').trim();
              } catch { explanation = raw; }
            } else { explanation = raw; }
          } else {
            explanation = raw.explanation || '';
            code = (raw.python_code || '').replace(/^```python?/,'').replace(/```$/,'').trim();
          }
          
          lockResponse();
          showResult(explanation, code);
          
        } else if (d.type === 'error') {
          stopThink();
          showError(d.message || 'Unknown error', d.details || '');
        } else if (d.type === 'cleared') {
          log('[WS] State cleared');
        }
      } catch (e) { 
        log('ws parse err: ' + e); 
      }
    }

    function lockResponse() {
      responseLocked = true;
      log('[LOCK] Response locked for 15 seconds');
      
      if (lockTimeout) {
        clearTimeout(lockTimeout);
      }
      
      lockTimeout = setTimeout(() => {
        responseLocked = false;
        log('[LOCK] Response unlocked');
      }, 15000);
    }

    function unlockResponse() {
      responseLocked = false;
      if (lockTimeout) {
        clearTimeout(lockTimeout);
        lockTimeout = null;
      }
      currentResponseContent = null;
      log('[LOCK] Response manually unlocked');
    }

    function connect() {
      // HARDCODED TOKEN (replace with your actual token)
      let authToken = '6GQZkm0FSqFTpZxh3lwxyhH-5FvzwVci78xfgaXNatk';
      
      // Fallback to localStorage if token changes
      const storedToken = localStorage.getItem('ws_auth_token');
      if (storedToken) {
        authToken = storedToken;
      }

      const wsUrl = `ws://127.0.0.1:8000/ws?token=${encodeURIComponent(authToken)}`;
      ws = new WebSocket(wsUrl);
      
      ws.onopen = () => {
        log('[WS] ✓ Connected securely');
        console.log('[WS] Connected with authentication');
      };
      
      ws.onclose = () => {
        log('[WS] Connection closed, reconnecting...');
        setTimeout(connect, 3000);
      };
      
      ws.onerror = (e) => {
        console.error('[WS] Error:', e);
        log('[WS] Connection error - check auth token');
        // Clear token on error so user can re-enter
        localStorage.removeItem('ws_auth_token');
      };
      
      ws.onmessage = handleWebSocketMessage;
    }

    function showResult(expl, code) {
      const safeExpl = expl ? `<div class="thinking">${escapeHtml(expl)}</div>` : '';
      const safeCode = code ? `<pre>${escapeHtml(code)}</pre>` : '';
      const content = safeExpl + safeCode;
      
      currentResponseContent = content;
      document.getElementById('result-content').innerHTML = content;
      panel.style.display = 'block';
      isResultVisible = true;
      const r = navbar.getBoundingClientRect();
      panel.style.top = (r.bottom + 10) + 'px';
      
      try { ipcRenderer.send('expand-overlay'); } catch {}
      log('[DISPLAY] Result shown and locked');
    }

    function showError(message, details) {
      const content = `
        <div class="error-message">
          <strong>${escapeHtml(message)}</strong>
          ${details ? `<p>${escapeHtml(details)}</p>` : ''}
        </div>
      `;
      document.getElementById('result-content').innerHTML = content;
      panel.style.display = 'block';
      isResultVisible = true;
      const r = navbar.getBoundingClientRect();
      panel.style.top = (r.bottom + 10) + 'px';
    }

    function hideResult() {
      panel.style.display = 'none';
      isResultVisible = false;
      unlockResponse();
    }

    function startThink() {
      thinking = true;
      const r = navbar.getBoundingClientRect();
      pill.style.top = (r.bottom + 10) + 'px';
      pill.classList.add('pill-thinking');
      pill.innerHTML = '<span class="dots">Thinking</span>';
      clearTimeout(tSlow); clearTimeout(tLong);
      tSlow = setTimeout(() => { 
        if (thinking) pill.innerHTML = '<span class="dots">Still thinking</span>'; 
      }, 8000);
      tLong = setTimeout(() => { 
        if (thinking) pill.innerHTML = 'Taking longer than expected…'; 
      }, 25000);
    }

    function stopThink() {
      thinking = false;
      clearTimeout(tSlow);
      clearTimeout(tLong);
      pill.classList.remove('pill-thinking');
      pill.style.display = 'none';
    }

    function updateSolveButton() {
      if (hasScreenshot) {
        solveBtn.classList.remove('disabled');
        solveBtn.title = 'Analyze the screenshot';
      } else {
        solveBtn.classList.add('disabled');
        solveBtn.title = 'Take a screenshot first';
      }
    }

    function capture() {
      if (ws?.readyState === 1) {
        unlockResponse();
        ws.send(JSON.stringify({type:'capture'}));
        shots++;
        cnt.textContent = `Shots: ${shots}`;
        
        // Mark that screenshot was taken
        hasScreenshot = true;
        updateSolveButton();
        log('[SCREENSHOT] Taken - Solve enabled');
      }
    }

    function solve() {
      // Check if screenshot was taken
      if (!hasScreenshot) {
        log('[SOLVE] ❌ Rejected - No screenshot');
        showError('Take a screenshot first', 'Press Ctrl+Shift+C to capture before solving');
        return;
      }
      
      if (ws?.readyState === 1) {
        startThink();
        ws.send(JSON.stringify({type:'solve'}));
        log('[SOLVE] Request sent');
      }
    }

    document.getElementById('screenshot').addEventListener('click', capture);
    document.getElementById('solve').addEventListener('click', solve);
    
    document.getElementById('start-over').addEventListener('click', () => {
      shots = 0;
      cnt.textContent = 'Shots: 0';
      hideResult();
      
      // Reset screenshot state
      hasScreenshot = false;
      updateSolveButton();
      log('[CLEAR] Screenshot state reset');
      
      if (ws?.readyState === 1) ws.send(JSON.stringify({type:'clear'}));
    });

    document.getElementById('copy-result').addEventListener('click', () =>
      navigator.clipboard.writeText(document.getElementById('result-content').innerText));
    
    document.getElementById('close-result').addEventListener('click', hideResult);

    pill.addEventListener('click', () => {
      navbar.style.display = 'flex';
      solve();
    });

    // IPC listeners
    ipcRenderer.on('screenshot', capture);
    ipcRenderer.on('solve', solve);
    ipcRenderer.on('start-over', () => document.getElementById('start-over').click());
    ipcRenderer.on('scroll-ai-result', (e, delta) => {
      if (panel.style.display !== 'none') {
        panel.scrollBy({top: delta, behavior: 'smooth'});
      }
    });
    
    function getAlpha() {
      return Math.min(.95, Math.max(.1, parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--overlay-alpha') || '.6')));
    }
    
    function setAlpha(v) {
      document.documentElement.style.setProperty('--overlay-alpha', String(Math.min(.95, Math.max(.1, v))));
    }
    
    ipcRenderer.on('set-transparency', (e, payload) => {
      const cur = getAlpha();
      if (payload?.action === 'inc') setAlpha(cur + .05);
      else if (payload?.action === 'dec') setAlpha(cur - .05);
      else if (typeof payload?.value === 'number') setAlpha(payload.value);
    });

    function escapeHtml(str) {
      return String(str)
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#039;');
    }

    // Initialize
    updateSolveButton();
    connect();
    log('[INIT] Secure overlay initialized');
  </script>
</body>
</html>